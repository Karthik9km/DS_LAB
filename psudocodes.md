>[!WARNING]  
>Psuodocodes are semi-generated by github copilot. Please check whether the psudocode matches your program before using it.
>This psudocodes might not be the one exactly used in repository. this is just for reference.

```
PROGRAM LINEARSEARCH

PROCEDURE LINEARSEARCH ACCEPTS array, size, key
    FOR i = 0 TO size - 1
        IF array[i] = key
            RETURN i
        END IF
    END FOR
    RETURN -1
END PROCEDURE

PROCEDURE MAIN
    READ size
    READ array[size]
    READ key
    SET index = LINEARSEARCH(array, size, key)
    IF index != -1
        PRINT "Element found at index ", index
    ELSE
        PRINT "Element not found"
    END IF
END PROCEDURE

END PROGRAM

```
### Binary Search[]: # Path: psudocodes.md
```
PROGRAM BINARYSEARCH

PROCEDURE BINARYSEARCH ACCEPTS array, size, key
    SET l = 0
    SET h = size - 1
    WHILE l <= h
        SET mid = (l + h) / 2
        IF array[mid] = key
            RETURN mid
        ELSE IF array[mid] < key
            SET l = mid + 1
        ELSE
            SET h = mid - 1
        END IF
    END WHILE
    RETURN -1
END PROCEDURE

PROCEDURE MAIN
    READ size
    READ array[size]
    READ key
    SET index = BINARYSEARCH(array, size, key)
    IF index != -1
        PRINT "Element found at index ", index
    ELSE
        PRINT "Element not found"
    END IF
END PROCEDURE

END PROGRAM

```

### Bubble Sort[]: # Path: psudocodes.md
```
PROGRAM BUBBLESORT

PROCEDURE BUBBLESORT ACCEPTS array, size
    FOR i = 0 TO size - 1
        FOR j = 0 TO size - i - 1
            IF array[j] > array[j + 1]
                SET temp = array[j]
                SET array[j] = array[j + 1]
                SET array[j + 1] = temp
            END IF
        END FOR
    END FOR
END PROCEDURE

PROCEDURE MAIN
    READ size
    READ array[size]
    CALL BUBBLESORT WITH array, size
    PRINT array[size]
END PROCEDURE

END PROGRAM

```

### Repeated Element[]: # Path: psudocodes.md
```
PROGRAM REPEATED_ELEMENT

PROCEDURE MAIN
    READ size
    READ array[size]
    SET count = 0
    FOR i = 0 TO size - 1
        FOR j = i + 1 TO size - 1
            IF array[i] = array[j]
                IF j<i
                    BREAK
                END IF
                SET count = count + 1
            END IF
        END FOR
        IF count > 0
            PRINT array[i] " is repeated " count " times"
        END IF
    END FOR
END PROCEDURE

END PROGRAM

```
### Second largest of an array[]: # Path: psudocodes.md
```
PROGRAM SECOND_LARGEST

PROCEDURE MAIN
    READ size
    READ array[size]
    SET largest = array[0]
    SET second_largest = array[0]
    FOR i = 0 TO size - 1
        IF array[i] > largest
            SET largest = array[i]
        ELSE 
            SET second_largest = array[i]
        END IF
    END FOR
    PRINT "Second largest element is " second_largest
END PROCEDURE

END PROGRAM

```

### Selection sort[]: # Path: psudocodes.md
```
PROGRAM SELECTIONSORT

PROCEDURE SELECTIONSORT ACCEPTS array, size
    FOR i = 0 TO size - 1
        SET min = i
        FOR j = i + 1 TO size - 1
            IF array[min] > array[j]
                SET temp = array[i]
                SET array[i] = array[min]
                SET array[min] = temp
            END IF
        END FOR
    END FOR
END PROCEDURE

PROCEDURE MAIN
    READ size
    READ array[size]
    CALL SELECTIONSORT WITH array, size
    PRINT array
END PROCEDURE

END PROGRAM

```

### Insertion sort[]: # Path: psudocodes.md
```
PROGRAM INSERTIONSORT

PROCEDURE INSERTIONSORT ACCEPTS array, size
    FOR i = 1 TO size - 1
        SET key = array[i]
        SET j = i - 1
        WHILE j >= 0 AND array[j] > key
            SET array[j + 1] = array[j]
            SET j = j - 1
        END WHILE
        SET array[j + 1] = key
    END FOR
END PROCEDURE

PROCEDURE MAIN
    READ size
    READ array[size]
    CALL INSERTIONSORT WITH array, size
    PRINT array
END PROCEDURE

END PROGRAM

```

### Polynomial Addition[]: # Path: psudocodes.md
```
PROGRAM POLYNOMIAL_ADDITION

DECLARE STRUCTURE POLYNOMIAL
    DECLARE INTEGER coefficient
    DECLARE INTEGER exponent
END STRUCTURE

PROCEDURE READ_POLYNOMIAL ACCEPTS polynomial
    READ number_of_terms
    FOR i = 0 TO number_of_terms - 1
        READ polynomial[i].coefficient
        READ polynomial[i].exponent
    END FOR
    RETURN number_of_terms
END PROCEDURE

PROCEDURE ADD_POLYNOMIAL ACCEPTS polynomial1, polynomial2, result, size1, size2
    SET i = 0
    SET j = 0
    SET k = 0
    WHILE i < size1 AND j < size2
        IF polynomial1[i].exponent = polynomial2[j].exponent
            SET result[k].coefficient = polynomial1[i].coefficient + polynomial2[j].coefficient
            SET result[k].exponent = polynomial1[i].exponent
            SET i = i + 1
            SET j = j + 1
            SET k = k + 1
        ELSE IF polynomial1[i].exponent > polynomial2[j].exponent
            SET result[k].coefficient = polynomial1[i].coefficient
            SET result[k].exponent = polynomial1[i].exponent
            SET i = i + 1
            SET k = k + 1
        ELSE
            SET result[k].coefficient = polynomial2[j].coefficient
            SET result[k].exponent = polynomial2[j].exponent
            SET j = j + 1
            SET k = k + 1
        END IF
    END WHILE
    WHILE i < size1
        SET result[k].coefficient = polynomial1[i].coefficient
        SET result[k].exponent = polynomial1[i].exponent
        SET i = i + 1
        SET k = k + 1
    END WHILE
    WHILE j < size2
        SET result[k].coefficient = polynomial2[j].coefficient
        SET result[k].exponent = polynomial2[j].exponent
        SET j = j + 1
        SET k = k + 1
    END WHILE
    RETURN k
END PROCEDURE

PROCEDURE DISPLAY_POLYNOMIAL ACCEPTS polynomial, size
    FOR i = 0 TO size - 1
        PRINT polynomial[i].coefficient "x^" polynomial[i].exponent
    END FOR
END PROCEDURE

PROCEDURE MAIN
    DECLARE POLYNOMIAL polynomial1[10]
    DECLARE POLYNOMIAL polynomial2[10]
    DECLARE POLYNOMIAL result[10]
    SET size1 = READ_POLYNOMIAL(polynomial1)
    PRINT polynomial1
    SET size2 = READ_POLYNOMIAL(polynomial2)
    PRINT polynomial2
    SET size = ADD_POLYNOMIAL(polynomial1, polynomial2, result, size1, size2)
    DISPLAY_POLYNOMIAL(result, size)
END PROCEDURE

END PROGRAM

```

### Stack[]: # Path: psudocodes.md
```
PROGRAM STACK

DEFINE SIZE 10

DECLARE ARRAY stack[SIZE]
SET top = -1

PROCEDURE ISEMPTY 
    IF top == -1
        RETURN TRUE
    ELSE
        RETURN FALSE
    END IF
END PROCEDURE

PROCEDURE ISFULL
    IF top == SIZE - 1
        RETURN TRUE
    ELSE
        RETURN FALSE
    END IF
END PROCEDURE

PROCEDURE PUSH ACCEPTS element
    IF !ISFULL
        SET top = top + 1
        INPUT stack[top]
    ELSE
        PRINT "Stack overflow"
    END IF
END PROCEDURE

PROCEDURE POP
    IF !ISEMPTY
        PRINT stack[top] " is popped"
        SET top = top - 1
    ELSE
        PRINT "Stack underflow"
    END IF
END PROCEDURE

PROCEDURE PEEK
    IF !ISEMPTY
        PRINT stack[top]
    ELSE
        PRINT "Stack underflow"
    END IF
END PROCEDURE

PROCEDURE DISPLAY
    IF !ISEMPTY
        FOR i = top TO 0 
            PRINT stack[i]
        END FOR
    ELSE
        PRINT "Stack underflow"
    END IF
END PROCEDURE

PROCEDURE MAIN
    WHILE TRUE
        PRINT "1. Display"
        PRINT "2. Push"
        PRINT "3. Pop"
        PRINT "4. Peek"
        PRINT "5. Exit"
        READ choice
        CASE choice OF
            1: DISPLAY
            2: READ element
               PUSH(element)
            3: POP
            4: PEEK
            5: EXIT
        END CASE
    END WHILE
END PROCEDURE
END PROGRAM

```

### Queue[]: # Path: psudocodes.md
```
PROGRAM QUEUE

DEFINE SIZE 10

DECLARE ARRAY queue[SIZE]
SET front = -1
SET rear = -1

PROCEDURE ISEMPTY
   RETURN front == -1 && rear == -1
END PROCEDURE

PROCEDURE ISFULL
    RETURN rear == SIZE - 1
END PROCEDURE

PROCEDURE ENQUEUE ACCEPTS
    IF ISEMPTY
        SET front = 0
        SET rear = 0
        INPUT queue[rear]
    ELSE IF ISFULL
        PRINT "Queue overflow"
    ELSE
        SET rear = rear + 1
        INPUT queue[rear]
    END IF
END PROCEDURE

PROCEDURE DEQUEUE
    IF ISEMPTY
        PRINT "Queue underflow"
    ELSE IF front > rear
        PRINT "Cannot dequeue"
    ELSE
        PRINT queue[front] " is dequeued"
        SET front = front + 1
    END IF
END PROCEDURE

PROCEDURE QSIZE
    IF ISEMPTY
        PRINT "Queue underflow"
    ELSE
        PRINT rear - front + 1
    END IF
END PROCEDURE

PROCEDURE DISPLAY
    IF !ISEMPTY
        FOR i = front TO rear
            PRINT queue[i]
        END FOR
    ELSE
        PRINT "Queue underflow"
    END IF
END PROCEDURE

PROCEDURE MAIN
    WHILE TRUE
        PRINT "1. Display"
        PRINT "2. Enqueue"
        PRINT "3. Dequeue"
        PRINT "4. Size"
        PRINT "5. Exit"
        READ choice
        CASE choice OF
            1: DISPLAY
            2: READ element
               ENQUEUE(element)
            3: DEQUEUE
            4: QSIZE
            5: EXIT
        END CASE
    END WHILE
END PROCEDURE

END PROGRAM

```

### Sparse Matrix Representation[]: # Path: psudocodes.md
```
PROGRAM SPARSE_MATRIX

DEFINE SIZE 10

PROCEDURE MAIN
    DECLARE ARRAY sparse_matrix[SIZE][SIZE]
    READ rows
    READ columns
    READ sparse_matrix[rows][columns]
    DECLARE ARRAY triplet[SIZE*SIZE][3]
    SET count = 0
    SET k = 1
    SET triplet[0][0] = rows
    SET triplet[0][1] = columns

    FOR i = 0 TO rows - 1
        FOR j = 0 TO columns - 1
            IF sparse_matrix[i][j] != 0
                SET triplet[k][0] = i
                SET triplet[k][1] = j
                SET triplet[k][2] = sparse_matrix[i][j]
                SET k = k + 1
                SET count = count + 1
            END IF
        END FOR
    END FOR

    SET triplet[0][2] = count

    PRINT triplet

END PROCEDURE
END PROGRAM

```

### Sparse Matrix Addition[]: # Path: psudocodes.md
```
PROGRAM SPARSE_MATRIX_ADDITION
DEFINE SIZE 10
PROCEDURE INPUTMATRIX ACCEPTS matrix, rows, columns
    FOR i = 0 TO rows - 1
        FOR j = 0 TO columns - 1
            READ matrix[i][j]
        END FOR
    END FOR
END PROCEDURE
PROCEDURE TRIPLETGEN ACCEPTS matrix, rows, columns, triplet
    SET count = 0
    SET k = 1
    SET triplet[0][0] = rows
    SET triplet[0][1] = columns
    FOR i = 0 TO rows - 1
        FOR j = 0 TO columns - 1
            IF matrix[i][j] != 0
                SET triplet[k][0] = i
                SET triplet[k][1] = j
                SET triplet[k][2] = matrix[i][j]
                SET k = k + 1
                SET count = count + 1
            END IF
        END FOR
    END FOR
    RETURN count
END PROCEDURE
PROCEDURE PRINTTRIPLET ACCEPTS triplet,size
    FOR i = 0 TO size
        FOR j = 0 TO 2
            PRINT triplet[i][j]
        END FOR
    END FOR
END PROCEDURE
PROCEDURE TRIPLETADDITION ACCEPTS triplet1, triplet2, triplet3, size1, size2
    SET i = 1
    SET j = 1
    SET k = 1
    WHILE i <= size1 AND j <= size2
        IF triplet1[i][0] == triplet2[j][0] AND triplet1[i][1] == triplet2[j][1]
            SET triplet3[k][0] = triplet1[i][0]
            SET triplet3[k][1] = triplet1[i][1]
            SET triplet3[k][2] = triplet1[i][2] + triplet2[j][2]
            SET i = i + 1
            SET j = j + 1
            SET k = k + 1
        ELSE IF triplet1[i][0] < triplet2[j][0] OR (triplet1[i][0] == triplet2[j][0] AND triplet1[i][1] < triplet2[j][1])
            SET triplet3[k][0] = triplet1[i][0]
            SET triplet3[k][1] = triplet1[i][1]
            SET triplet3[k][2] = triplet1[i][2]
            SET i = i + 1
            SET k = k + 1
        ELSE
            SET triplet3[k][0] = triplet2[j][0]
            SET triplet3[k][1] = triplet2[j][1]
            SET triplet3[k][2] = triplet2[j][2]
            SET j = j + 1
            SET k = k + 1
        END IF
    END WHILE
    WHILE i <= size1
        SET triplet3[k][0] = triplet1[i][0]
        SET triplet3[k][1] = triplet1[i][1]
        SET triplet3[k][2] = triplet1[i][2]
        SET i = i + 1
        SET k = k + 1
    END WHILE
    WHILE j <= size2
        SET triplet3[k][0] = triplet2[j][0]
        SET triplet3[k][1] = triplet2[j][1]
        SET triplet3[k][2] = triplet2[j][2]
        SET j = j + 1
        SET k = k + 1
    END WHILE
    RETURN k
END PROCEDURE
PROCEDURE MAIN
    DECLARE ARRAY matrix1[SIZE][SIZE]
    DECLARE ARRAY matrix2[SIZE][SIZE]
    READ rows1
    READ columns1
    READ rows2
    READ columns2
    IF(rows1 != rows2 OR columns1 != columns2)
        PRINT "Matrices cannot be added"
        EXIT
    END IF
    INPUTMATRIX(matrix1, rows1, columns1)
    INPUTMATRIX(matrix2, rows2, columns2)

    DECLARE ARRAY triplet1[SIZE*SIZE][3]
    DECLARE ARRAY triplet2[SIZE*SIZE][3]

    SET size1 = TRIPLETGEN(matrix1, rows1, columns1, triplet1)
    SET size2 = TRIPLETGEN(matrix2, rows2, columns2, triplet2)

    PRINTTRIPLET(triplet1, size1)
    PRINTTRIPLET(triplet2, size2)

    DECLARE ARRAY triplet3[SIZE*SIZE][3]
    SET tripet3[0][0] = rows1
    SET tripet3[0][1] = columns1

    SET size3 = TRIPLETADDITION(triplet1, triplet2, triplet3, size1, size2)

    SET triplet3[0][2] = size3 - 1

    PRINTTRIPLET(triplet3, size3)

END PROCEDURE
END PROGRAM

```
### Circular Queue[]: # Path: psudocodes.md
```
PROGRAM CIRCULAR_QUEUE

DEFINE SIZE 10

DECLARE ARRAY queue[SIZE]
SET front = -1
SET rear = -1

PROCEDURE ISEMPTY
    RETURN front == -1 && rear == -1
END PROCEDURE

PROCEDURE ISFULL
    RETURN (rear + 1) % SIZE == front
END PROCEDURE

PROCEDURE ENQUEUE ACCEPTS element
    IF !ISFULL
        IF ISEMPTY
            SET front = 0
            SET rear = 0
        ELSE
            SET rear = (rear + 1) % SIZE
        END IF
        INPUT queue[rear]
    ELSE
        PRINT "Queue is full"
    END IF
END PROCEDURE

PROCEDURE RESET
    SET front = -1
    SET rear = -1
END PROCEDURE

PROCEDURE DEQUEUE
    IF !ISEMPTY
        PRINT queue[front] " is dequeued"
        IF front == rear
            CALL RESET
        ELSE
            SET front = (front + 1) % SIZE
        END IF
    ELSE
        PRINT "Queue is empty"
    END IF
END PROCEDURE

PROCEDURE DISPLAY
    IF ISEMPTY
        PRINT "Queue is empty"
        RETURN
    END IF
    SET i = front
    WHILE i != rear
        PRINT queue[i]
        SET i = (i + 1) % SIZE
    END WHILE
    PRINT queue[rear]
END PROCEDURE

PROCEDURE MAIN
    WHILE TRUE
        PRINT "1. Display"
        PRINT "2. Enqueue"
        PRINT "3. Dequeue"
        PRINT "4. Exit"
        READ choice
        CASE choice OF
            1: CALL DISPLAY
            2: CALL ENQUEUE
            3: CALL DEQUEUE
            4: EXIT
        END CASE
    END WHILE
END PROCEDURE

END PROGRAM

```
### Priority Queue[]: # Path: psudocodes.md
```
PROGRAM PRIORITY_QUEUE
DEFINE SIZE 5
DECLARE ARRAY queue[SIZE]
SET front = -1
SET rear = -1
PROCEDURE ISEMPTY
    RETURN front == -1 && rear == -1
END PROCEDURE
PROCEDURE ISFULL
    RETURN rear == SIZE - 1
END PROCEDURE
PROCEDURE ENQUEUE
    IF ISFULL
        PRINT "Queue overflow"
    ELSE
        IF ISEMPTY
            SET front = 0
            SET rear = 0
        ELSE
            SET rear = rear + 1
        END IF
        READ key
        SET j = rear - 1
        WHILE j >= 0 AND queue[j] > key
            SET queue[j + 1] = queue[j]
            SET j = j - 1
        END WHILE
        SET queue[j + 1] = key
    END IF
END PROCEDURE
PROCEDURE DEQUEUE
    IF ISEMPTY
        PRINT "Queue underflow"
    ELSE IF front > rear
        PRINT "Cannot dequeue"
    ELSE
        PRINT queue[front] " is dequeued"
        SET front = front + 1
    END IF
END PROCEDURE
PROCEDURE SIZE 
    IF ISEMPTY
        PRINT "Queue underflow"
    ELSE
        PRINT rear - front + 1
    END IF
END PROCEDURE
PROCEDURE DISPLAY
    IF !ISEMPTY
        FOR i = front TO rear
            PRINT queue[i]
        END FOR
    ELSE
        PRINT "Queue underflow"
    END IF
END PROCEDURE
PROCEDURE MAIN
    WHILE TRUE
        PRINT "1. Display"
        PRINT "2. Enqueue"
        PRINT "3. Dequeue"
        PRINT "4. Size"
        PRINT "5. Exit"
        READ choice
        CASE choice OF
            1: CALL DISPLAY
            2: CALL ENQUEUE
            3: CALL DEQUEUE
            4: CALL SIZE
            5: CALL EXIT
        END CASE
    END WHILE
END PROCEDURE
END PROGRAM

```